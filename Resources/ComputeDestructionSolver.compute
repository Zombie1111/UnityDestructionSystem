#include "ComputeGlobalSettings.cginc"


struct FracWeight
{
    int stWe_lenght;
    int structsI[maxDeformationBones];
    float weights[maxDeformationBones];
};

struct BoneWeight
{
    float weight0;
    float weight1;
    float weight2;
    float weight3;
    int boneIndex0;
    int boneIndex1;
    int boneIndex2;
    int boneIndex3;
};

struct MeshData
{
    float3 vertexL;
    float3 normalL;
    int verToPartI;
};

struct BendProperties
{
    float bendyness;
    float bendStrenght;
    float bendFalloff;
    float bendPower;
};

struct DefPoint
{
    float3 defPos;
    float3 defVel;
    float disToWall;
    int parentI;
    int partI;
};

inline float4x4 inverse(float4x4 m)
{
    float n11 = m[0][0], n12 = m[1][0], n13 = m[2][0], n14 = m[3][0];
    float n21 = m[0][1], n22 = m[1][1], n23 = m[2][1], n24 = m[3][1];
    float n31 = m[0][2], n32 = m[1][2], n33 = m[2][2], n34 = m[3][2];
    float n41 = m[0][3], n42 = m[1][3], n43 = m[2][3], n44 = m[3][3];

    float t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    float t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    float t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    float t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

    float det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    float idet = 1.0f / det;

    float4x4 ret;

    ret[0][0] = t11 * idet;
    ret[0][1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * idet;
    ret[0][2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * idet;
    ret[0][3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * idet;

    ret[1][0] = t12 * idet;
    ret[1][1] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * idet;
    ret[1][2] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * idet;
    ret[1][3] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * idet;

    ret[2][0] = t13 * idet;
    ret[2][1] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * idet;
    ret[2][2] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * idet;
    ret[2][3] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * idet;

    ret[3][0] = t14 * idet;
    ret[3][1] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * idet;
    ret[3][2] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * idet;
    ret[3][3] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * idet;

    return ret;
}

inline float3 vec3LerpMin(float3 current, float3 target, float t, float min, out bool reachedTarget)
{
    //Does not seem to work
    float3 vel = target - current;
    float dis = sqrt(dot(vel, vel));
    if (dis <= min)
    {
        reachedTarget = true;
        return target;
    }

    dis *= t;
    if (dis < min) dis = min;

    reachedTarget = false;
    return current + (normalize(vel) * dis);
}

//skinning stuff
int partBoneOffset; //allFracBonesLToW[partI + partBoneOffset] is the LToW matrix for the part
int fracRendVerCount; //The number of vertics in the frac mesh
float4x4 fracRendWToL; //The WToL matrix for the frac mesh
RWStructuredBuffer<float4x4> allFracBonesLToW; //The LToW matrix for every bone
RWStructuredBuffer<BoneWeight> fr_boneWeightsCurrent; //The bone weight for every vertex in frac mesh
RWStructuredBuffer<MeshData> fr_meshData;

//bend stuff
int defPointsLenght = 0;
float defBendForce = 0.0f;
RWStructuredBuffer<DefPoint> defPoints;
RWStructuredBuffer<BendProperties> bendProperties;
RWStructuredBuffer<int> partIToBendPropI;
RWStructuredBuffer<int> partIToParentI; //The parent part X has

#pragma kernel ComputeSkinDef
#if defined(SUPPORTVERTEXCOLORS)
#define VERTEX_32BIT_STRIDE 10 // float3 position, float3 normal, float4 color
#define SUPPORTVERTEXCOLORS_ON 1
#else
#define VERTEX_32BIT_STRIDE 6 // float3 position, float3 normal 
#define SUPPORTVERTEXCOLORS_ON 0
#endif

#define NORMAL_OFFSET 3 // float3 position, 
#define COLOR_OFFSET 6 // float3 position, float3 normal

RWByteAddressBuffer verNors;

[numthreads(128, 1, 1)]
void ComputeSkinDef(uint3 id : SV_DispatchThreadID)
{
    //return if out of bounds
    if (id.x >= (uint)fracRendVerCount) return;
    
    //get skin bone matrix
    BoneWeight boneWeight = fr_boneWeightsCurrent[id.x];
    float4x4 boneMatrixLToW = allFracBonesLToW[boneWeight.boneIndex0] * boneWeight.weight0 +
        allFracBonesLToW[boneWeight.boneIndex1] * boneWeight.weight1 +
        allFracBonesLToW[boneWeight.boneIndex2] * boneWeight.weight2 +
        allFracBonesLToW[boneWeight.boneIndex3] * boneWeight.weight3;
    
    //deform mesh
    MeshData meshD = fr_meshData[id.x];
    
    if (defPointsLenght > 0)
    {
        float3 offsetW = float3(0.0f, 0.0f, 0.0f);
        int parentI = partIToParentI[meshD.verToPartI];
        BendProperties bendProp = bendProperties[partIToBendPropI[meshD.verToPartI]];
        float bendStrenght = bendProp.bendStrenght;
        float bendForce = defBendForce > bendStrenght ? bendStrenght : defBendForce;
        
        #if SUPPORTVERTEXCOLORS_ON
        float vColA = defBendForce;
        #endif
        
        for (int dpI = 0; dpI < defPointsLenght; dpI++)
        {
            DefPoint defPoint = defPoints[dpI];
        
            if (defPoint.parentI != parentI) continue;
                        
            float3 disVel = mul(boneMatrixLToW, float4(meshD.vertexL, 1.0)).xyz - defPoint.defPos;
            float falloffX = sqrt(dot(disVel, disVel)) * bendProp.bendFalloff;
            falloffX += falloffX * (falloffX * bendProp.bendPower);
            
            #if SUPPORTVERTEXCOLORS_ON
            if (falloffX > defBendForce)
                continue;
            
            if (falloffX < vColA)
                vColA = falloffX;
            #endif
            
            if (falloffX > bendForce)
                continue;

            offsetW += bendProp.bendyness * clamp((bendForce - falloffX) / (bendStrenght * sqrt(dot(defPoint.defVel, defPoint.defVel))), 0.0f, 1.0f) * defPoint.defVel;
        }
    
        meshD.vertexL += mul((float3x3) inverse(boneMatrixLToW), offsetW);
        //meshD.normalL is currently not deformed, we probably also need mesh triangels to be able to calculate new normal??
        fr_meshData[id.x] = meshD;

        #if SUPPORTVERTEXCOLORS_ON
        //Apply vertex colors
        vColA /= defBendForce;
        vColA = 1.0f - vColA;
        vColA *= bendForce / bendStrenght;
        
        float4 oldVCol = asfloat(verNors.Load4(((id.x * VERTEX_32BIT_STRIDE) + COLOR_OFFSET) << 2));
        //if (vColA > oldVCol.a)
        //    verNors.Store4(((id.x * VERTEX_32BIT_STRIDE) + COLOR_OFFSET) << 2, asuint(float4(oldVCol.rgb, vColA)));
        if (vColA > oldVCol.a * 0.25f)
            verNors.Store4(((id.x * VERTEX_32BIT_STRIDE) + COLOR_OFFSET) << 2, asuint(float4(oldVCol.rgb, clamp((oldVCol.a * 0.75f) + vColA, 0.0f, 1.0f))));
        #endif
    }
    
    //Write updated vertics and normals to mesh
    //Add an option to do interpolation
    verNors.Store3((id.x * VERTEX_32BIT_STRIDE) << 2, asuint(mul(fracRendWToL, mul(boneMatrixLToW, float4(meshD.vertexL, 1.0))).xyz));
    verNors.Store3(((id.x * VERTEX_32BIT_STRIDE) + NORMAL_OFFSET) << 2, asuint(mul((float3x3) fracRendWToL, mul((float3x3) boneMatrixLToW, meshD.normalL))));
}

RWStructuredBuffer<MeshData> og_frMeshData; //The MeshData values we had at start
RWStructuredBuffer<int> partIWannaRestore; //if partIWannaRestore[partI] is true, partI should be restored
//RWStructuredBuffer<int> isRepairDone;
//float repairSpeedDelta;

#pragma kernel RestoreSkinDef

[numthreads(128, 1, 1)]
void RestoreSkinDef(uint3 id : SV_DispatchThreadID)
{
    //return if out of bounds
    if (id.x >= (uint) fracRendVerCount) return;
    
    //return if dont wanna restore
    MeshData meshD = fr_meshData[id.x];
    if (partIWannaRestore[meshD.verToPartI] == 0) return;

    MeshData meshDOg = og_frMeshData[id.x];
    
    //bool doneA;
    //meshD.vertexL = vec3LerpMin(meshD.vertexL, meshDOg.vertexL, repairSpeedDelta, repairSpeedDelta * 2.0f, doneA);
    //
    //bool doneB;
    //meshD.normalL = vec3LerpMin(meshD.normalL, meshDOg.normalL, repairSpeedDelta, repairSpeedDelta * 2.0f, doneB);
    
    meshD.vertexL = meshDOg.vertexL;
    meshD.normalL = meshDOg.normalL;
    
    fr_meshData[id.x] = meshD;
    partIWannaRestore[meshD.verToPartI] = false;
}

